# 堆内存串行分配修复方案

## 问题描述

在文件地址输入启动时发现堆内存分配问题，可能导致堆损坏。主要问题集中在以下几个方面：

1. **并发内存分配**：多个线程同时进行内存分配和释放
2. **动态内存扩展**：向量容器的动态增长导致频繁重新分配
3. **不安全的内存复制**：使用迭代器进行内存操作时可能出现失效

## 修复措施

### 1. FileAudioInput::processFile() 串行化修复

#### 文件访问串行化
- 使用 `std::unique_ptr<std::ifstream>` 管理文件流
- 添加异常处理确保文件流创建失败时的安全退出

#### 内存分配串行化
- **WAV头读取**：预分配固定大小内存，避免动态扩展
- **音频缓冲区**：预分配最大可能大小，避免循环中重新分配
- **批处理缓冲区**：预分配批处理容量，避免动态扩展
- **音频数据转换**：预分配转换缓冲区，仅在必要时调整大小

#### 数据处理串行化
- **单声道转换**：预分配目标缓冲区，避免临时分配
- **批处理推送**：使用移动语义避免数据复制
- **内存重用**：在循环中重用已分配的内存

### 2. WavFileUtils 串行化修复

#### createWavFromBuffers() 方法
- **总大小计算**：串行化计算，避免并发访问
- **内存分配**：一次性分配完整大小，避免动态扩展
- **数据复制**：使用指针算术和 `memcpy` 进行安全复制
- **边界检查**：添加缓冲区边界检查防止溢出
- **完整性验证**：验证复制的数据量与预期一致

#### saveWavBatch() 方法
- **预分配缓冲区**：一次性分配完整大小
- **串行化合并**：使用 `memcpy` 替代 `insert()` 操作
- **异常处理**：处理内存分配失败的情况

## 关键技术要点

### 内存分配策略
```cpp
// 串行化内存分配模式
std::vector<float> buffer;
try {
    buffer.reserve(total_size);  // 预分配容量
    buffer.resize(total_size);   // 设置实际大小
} catch (const std::bad_alloc& e) {
    // 处理内存分配失败
}
```

### 安全内存复制
```cpp
// 使用指针算术和 memcpy 避免迭代器失效
float* dest_ptr = combined.data();
std::memcpy(dest_ptr + offset, src_data, size * sizeof(float));
```

### 移动语义优化
```cpp
// 使用移动语义避免不必要的复制
batchBuffers.emplace_back(std::move(audio_buffer));
processedAudioData = std::move(audioData);
```

## 预期效果

1. **避免堆损坏**：通过串行化内存分配消除并发访问问题
2. **提高性能**：减少内存重新分配和数据复制次数
3. **增强稳定性**：添加边界检查和异常处理
4. **改善内存使用**：通过预分配和重用减少内存碎片

## 验证建议

1. **内存检测工具**：使用 Application Verifier 或 Valgrind 检测堆损坏
2. **压力测试**：多次处理大文件验证稳定性
3. **性能监控**：监控内存使用和分配次数
4. **异常处理测试**：测试内存分配失败时的处理

## 兼容性说明

- 保持原有 API 接口不变
- 所有修改都是内部实现优化
- 不影响现有功能的使用方式
- 向后兼容原有的调用代码 